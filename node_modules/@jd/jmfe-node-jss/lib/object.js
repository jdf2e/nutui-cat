/**
 * @file
 * @author Zeng Tong
 * Created on 2017-09-07.
 */

'use strict';

const _ = require('lodash');
const Promise = require('bluebird');
const crypto = require('crypto');
const mime = require('mime');
const zlib = require('zlib');
const stream = require('stream');
var util = require('./util');


/**
 * JssObject 类型<br>
 * Object 是京东云存储中的基本实体，由键(Key)，数据(Data)和元数据(Metadata)三部分组成。关于数据(Data)，京东云存储并不关心其内容具体是什么。而元数据(Metadata)则是一组键值(Key-Value)的组合，包括数据的长度，创建时间，MD5 值等。<br>
 *
 */
class JssObject {
    /**
     * 创建一个 JssObject 实例
     * @public
     * @param {string} key Object 的 key<br>
     * Key 是一个 Object 的标识，在每一个 Bucket 中，每个 Object 有且仅有一个 Key。而用户可以通过 Bucket + Key 的方式唯一标识云存储中的一个 Object，例如对于 URL:http://storage.jcloud.com/mybucket/public/index.html域名之后到第一个斜线（/）是 Bucket，为 mybucket，之后是 Object 的 Key，为public/index.html<br>
     * @param {Bucket} bucket Object 所属的 Bucket 实例
     * @param {Client} client Client 实例
     */
    constructor(key, bucket, client) {
        this.key = key;
        this.bucket = bucket;
        this.client = client;
        if (!( _.isString(key) && key.trim().length > 0)) {
            return new Error('参数 key 必须为非空字符串');
        }
    }


    /**
     * 下载一个资源并读取其内容<br>
     * @public
     * @returns {Promise.<Response.body>} resolve，成功时 statusCode 为 200, resolve 获得文件内容 <br>
     * @returns {Promise.<Error>} reject，失败时为错误对象; 例如资源不存在时 statusCode 为 404，消息为 `{"code":"NoSuchKey","message":"The specified key does not exist.","resource":"/protest/test.html","requestId":"90517BDD0F94D467"}` <br>
     * @example
     * jss.bucket('pro-test').object('test.html').get()
     *    .then(function (res) {
     *        console.log(res) // 这里输出的是文件内容
     * }).catch(function (err) {
     *     console.log('出错啦')
     *     console.log(err)
     * })
     */
    get(isStream) {
        var self = this;
        var bucketName = self.bucket.name;
        var objectKey = self.key;
        var request = {
            method: 'GET',
            uri: '/' + bucketName + '/' + objectKey,
            isStream: Boolean(isStream),
        }
        return self.client.execute(request);
    }



    /**
     * 上传或替换一个资源 <br>
     * @public
     * @param {string} path 要上传资源的本地路径 <br>
     * @returns {Promise.<Response.body>} resolve，成功时 statusCode 为 200, 返回的Body为空; <br>
     * @returns {Promise.<Error>} reject，失败时为错误对象 <br>
     * @example
     * jss.bucket('pro-test').object('test.html').put('/file/path')
     *    .then(function (res) {
     *        console.log('上传资源成功')
     *        console.log(res)
     * }).catch(function (err) {
     *     console.log('出错啦')
     *     console.log(err)
     * })
     */
    put(path, headers) {
        var self = this;
        var bucketName = self.bucket.name;
        var objectKey = self.key;
        if (!( _.isString(path) && path.trim().length > 0)) {
            return Promise.reject(new Error('参数 path 必须为非空字符串'));
        }
        return Promise.coroutine(function *() {
            var inStream1, inStream2;
            try {
                [inStream1, inStream2] = yield Promise.all([util.createReadStreamPromise(path), util.createReadStreamPromise(path)]);
            } catch (err) {
                return Promise.reject(err)
            }
            var md5Value = yield util.calcMd5(inStream1);
            var opt = {
                uri: '/' + bucketName + '/' + objectKey,
                method: 'PUT',
                headers: Object.assign({
                    'content-md5': md5Value,
                    'content-type': mime.lookup(path),
                    // 'content-disposition': ''
                }, headers),
                body: inStream2,
            }
            try {
                var putFileResult = yield self.client.execute(opt);
                return Promise.resolve('保存文件成功');
            } catch (err) {
                return Promise.reject(err)
            }
        })()
    }

    /**
     * 将内容上传并生成对应文件
     * @param {string|Buffer} value
     * @param {object} headers
     */
    putBody(value, headers) {
        var self = this;
        var bucketName = self.bucket.name;
        var objectKey = self.key;
        if (!(typeof value === 'string' || Buffer.isBuffer(value))) {
            return Promise.reject(new Error('参数 value 必须为字符串或Buffer'));
        }
        return Promise.coroutine(function *() {
            var md5Value = util.calcMd5ForContent(value);
            var opt = {
                uri: '/' + bucketName + '/' + objectKey,
                method: 'PUT',
                headers: Object.assign({
                    'content-md5': md5Value,
                    'content-type': 'text/plain; charset=utf-8',
                    'content-disposition': ''
                }, headers),
                body: value,
            }
            try {
                var putFileResult = yield self.client.execute(opt);
                return Promise.resolve('保存文件成功');
            } catch (err) {
                return Promise.reject(err)
            }
        })()
    }


    /**
     * 下载资源并保存到本地<br>
     * 提供流式文件下载，以及下载进度回调<br>
     * @public
     * @param {Object} options - 入参字段及含义如下：<br>
     * @param {Object} options.targetPath - 要保存的目标路径
     * @param {Object} options.finishCb - 任务完成回调; `function(error, transferredLength){}` 第一个参数为 error，如果不为空，说明出错啦; 第二个参数是下载完成的内容大小，单位为字节
     * @param {Object} options.progressCb - 下载进度回调; `function(progressInfo){}` , progressInfo 是一个对象，字段及其含义如下：<br> transferred,表示已经下载的大小;<br> contentLength，表示文件的总大小，单位为字节;<br> percentage，下载完成的百分比;<br> runtime，已经消耗的时间;<br> speed，下载速度单位为 byte/s <br>
     * @param {Object} options.throttleInterval - 下载进度回调的触发节流，需设置为 必须大于 0 并小于 10000 的整数，若不设置，默认 100 毫秒触发一次
     * @example
     * jss.bucket('pro-test').object('object-name-here').saveToFile({
     *     targetPath: '/your/target/path/here',
     *     finishCb: function (err, contentLength) {
     *         if (err) {
     *             console.log(err.message);
     *             return;
     *         }
     *         console.log('文件下载完成，体积：' + (contentLength / 1024) + ' kb');
     *     },
     *     progressCb: function (progress) {
     *         console.log(progress);
     *     },
     *     throttleInterval: 200
     * });
     */
    saveToFile(options) {
        var self = this;
        var targetPath = options.targetPath;
        var progressCb = options.progressCb;
        var finishCb = options.finishCb;
        var throttleInterval = parseInt(options.throttleInterval);
        var bucketName = self.bucket.name;
        var objectKey = self.key;
        if (!( _.isString(targetPath) && targetPath.trim().length > 0)) {
            return new Error('参数 path 必须为非空字符串');
        }
        if (!(throttleInterval > 0 && throttleInterval < 10000)) {
            return new Error('参数 throttleInterval 必须大于 0 并小于 10000');
        }
        var request = {
            throttleInterval: throttleInterval,
            progressCb: progressCb,
            finishCb: finishCb,
            targetFilePath: targetPath,
            method: 'GET',
            uri: '/' + bucketName + '/' + objectKey
        }
        self.client.request(request);
    }


    /**
     * 获取资源的元数据<br>
     * @public
     * @returns {Promise.<Response.body>} resolve，成功时 statusCode 为 200, resolve 的内容为元数据，形如： <br>
     *
     *```js
     *{ server: 'JDWS/1.0.0',
     *date: 'Fri, 15 Sep 2017 08:59:50 GMT',
     *'content-type': 'text/plain',
     *'content-length': '0',
     *connection: 'close',
     *'x-jss-request-id': 'B5E4E800DEF0CA13',
     *'content-disposition': 'attachment; filename="pro-a.txt"',
     *'accept-ranges': 'bytes',
     *etag: '"0cc175b9c0f1b6a831c399e269772661"',
     *'last-modified': 'Mon, 11 Sep 2017 17:47:04 GMT',
     *expires: 'Fri, 15 Sep 2017 08:59:50 GMT',
     *'cache-control': 'max-age=0' }
     *
     *```
     *
     * @returns {Promise.<Error>} reject，失败时为错误对象;<br>
     * @example
     *```js
     *jss.bucket('pro-test').object('pro-a.txt').head().then(function (res) {
     *    console.log(res)
     *}).catch(function (err) {
     *    console.log('出错啦')
     *    console.log(err)
     *})
     *```
     */
    head() {
        var self = this;
        var bucketName = self.bucket.name;
        var objectKey = self.key;
        var request = {
            method: 'HEAD',
            uri: '/' + bucketName + '/' + objectKey
        }
        return self.client.execute(request);
    }


    /**
     * 判断某个资源是否存在<br>
     * @public @returns {Promise.<Response.body>} resolve，资源存在时为 true， 不存在时为 false <br>
     *
     * @returns {Promise.<Error>} reject，失败时为错误对象;<br>
     * @example
     *```js
     *jss.bucket('pro-test').object('pro-a.txt').exist().then(function (res) {
     *    console.log(res)
     *}).catch(function (err) {
     *    console.log('出错啦')
     *    console.log(err)
     *})
     *```
     */

    exist() {
        var self = this;
        return Promise.coroutine(function *() {
            try {
                var head = yield self.head();
                if (head) {
                    return Promise.resolve(true);
                }
                return Promise.resolve(false);
            } catch (err) {
                if (err.name === 'StatusCodeError' && err.statusCode === 404) {
                    return Promise.resolve(false);
                } else {
                    return Promise.reject(err)
                }
            }
        })();
    }

    /**
     * 删除资源<br>
     * @public @returns {Promise.<Response.body>} resolve，成功时 statusCode 为 200, 返回的Body为空; <br>
     *
     * @returns {Promise.<Error>} reject，失败时为错误对象;<br>
     * @example
     *```js
     *jss.bucket('pro-test').object('pro-a.txt').delete().then(function (res) {
     *    console.log(res)
     *}).catch(function (err) {
     *    console.log('出错啦')
     *    console.log(err)
     *})
     *```
     */
    delete() {
        var self = this;
        var bucketName = self.bucket.name;
        var objectKey = self.key;
        var request = {
            method: 'DELETE',
            uri: '/' + bucketName + '/' + objectKey
        }
        return self.client.execute(request);
    }

    /**
     *
     * @returns {*}
     * @example
     *```js
     *jss.bucket('protest').object('multi.txt').initMultipartUpload().then(function (res) {
     *    console.log(res)
     *}).catch(function (err) {
     *    console.log('出错啦')
     *    console.log(err)
     *})
     *```

    initMultipartUpload() {
        var self = this;
        var bucketName = self.bucket.name;
        var objectKey = self.key;
        var request = {
            method: 'POST',
            uri: '/' + bucketName + '/' + objectKey + '?uploads'
        }
        return self.client.execute(request);
    }

    multiTest() {
        var self = this;
        return Promise.coroutine(function *() {
            var file = '/home/zengtong/test.html';
            var mimeType = mime.lookup(file);

            var [md5Value,inputStream] = yield Promise.all([util.calcMd5(file), util.createReadStreamPromise(file)]);
            console.log('md5Value=' + md5Value);
            var uploadPart = yield self.uploadPart('970CFED6AD2C3F1C', 1, {
                inputStream: inputStream,
                md5: md5Value,
                mimeType: mimeType
            })
        })();

    }

    uploadPart(uploadId, partNumber, options) {
        var self = this;
        var bucketName = self.bucket.name;
        var objectKey = self.key;
        var {inputStream, md5, mimeType}=options;
        console.log(md5);
        console.log(mimeType);
        console.log(inputStream);
        var request = {
            method: 'PUT',
            uri: '/' + bucketName + '/' + objectKey + '?partNumber',
            headers: {
                'content-md5': md5,
                'content-type': mimeType
            },
            qs: {
                partNumber: partNumber,
                uploadId: uploadId
            },
            body: inputStream,
        }
        return self.client.execute(request);
    }*/

}

module.exports = JssObject;
