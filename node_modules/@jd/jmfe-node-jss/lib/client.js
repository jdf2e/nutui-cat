/**
 * @file
 * @author Zeng Tong
 * Created on 2017-09-08.
 */

'use strict';

const httpRequest = require('request-promise');
const request = require('request');
const _ = require('lodash');
const fs = require('fs-extra');
const auth = require('./auth');

class Client {
    constructor(scheme, endpoint, accessKey, secretKey) {
        this.scheme = scheme;
        this.endpoint = endpoint;
        this.accessKey = accessKey;
        this.secretKey = secretKey;
        this.baseUrl = scheme + '://' + endpoint;
        this.defaultRequestOptions = {};
    }

    execute(opt) {
        const isStream = opt.isStream;
        var self = this;
        var options = {
            headers: {
                date: new Date().toUTCString()
            },
            baseUrl: self.baseUrl,
            timeout: 3000,
            gzip: true
        };
        _.merge(options, this.defaultRequestOptions, opt, {isStream: undefined});
        options.headers.authorization = auth(options, this.accessKey, this.secretKey);
        options.uri = encodeURI(opt.uri || '/');
        if (isStream) {
            return request(options);
        }
        return httpRequest(options);
    }

    request(opt, callback) {
        var self = this;
        var options = {
            headers: {
                date: new Date().toUTCString()
            },
            baseUrl: self.baseUrl,
            timeout: 3000,
            gzip: true
        };
        _.merge(options, this.defaultRequestOptions, opt);
        options.headers.authorization = auth(options, this.accessKey, this.secretKey);
        var targetPath = opt.targetFilePath;
        var noop = function () {
        };
        var finishCb = _.isFunction(opt.finishCb) ? opt.finishCb : noop;
        var progressCb = _.isFunction(opt.progressCb) ? opt.progressCb : noop;
        if (opt.throttleInterval > 0) {
            progressCb = _.throttle(progressCb, opt.throttleInterval);
        }
        var length;
        var rs = request(options, callback);
        // 提供流式文件下载，以及下载进度
        if (targetPath) {
            fs.ensureFile(targetPath, err => {
                if (err) {
                    return finishCb && finishCb(err);
                }
                rs.on('response', function (response) {
                    var beginTime = Date.now();
                    length = response.headers['content-length'];
                    var statusCode = response.statusCode;
                    var transferred = 0;
                    if (statusCode === 200) {
                        var ws = fs.createWriteStream(targetPath);
                        ws.on('finish', function () {
                            return finishCb && finishCb(null, transferred);
                        }).on('error', function (err) {
                            return finishCb && finishCb(err);
                        });
                        rs.on('data', function (chunk) {
                            var chunkLength = chunk.byteLength;
                            transferred += chunkLength;
                            if (progressCb) {
                                var runtimeMs = Date.now() - beginTime;
                                var runtime = parseInt(runtimeMs / 1000);
                            }
                            progressCb && progressCb({
                                transferred: transferred,
                                contentLength: length,
                                percentage: transferred / length * 100,
                                runtime: runtime,
                                speed: (transferred / runtimeMs) * 1000
                            });
                        });
                        rs.pipe(ws);
                    } else {
                        var body = '';
                        response.on('data', function (chunk) {
                            body += chunk;
                        });
                        response.on('end', function () {
                            var msg = statusCode + ' - ' + body;
                            var statusCodeError = new Error(msg);
                            statusCodeError.statusCode = statusCode;
                            return finishCb && finishCb(statusCodeError);
                        });
                    }
                }).on('error', function (err) {
                    return finishCb && finishCb(err);
                });
            });
        }
    }
}

module.exports = Client;
